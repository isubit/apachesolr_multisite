<?php
// $Id$

/**
 * @file
 *   Provides a multi-site search implementation for use with the Apache Solr module
 */

 /**
 * Implementation of hook_menu_alter().
 */
function apachesolr_multisitesearch_menu_alter(&$menu) {
  if (isset($menu['search/apachesolr_multisitesearch/%menu_tail'])) {
    $menu['search/apachesolr_multisitesearch/%menu_tail']['page callback'] = 'apachesolr_search_view';
  }
}

/**
 * Implementation of hook_search()
 */
function apachesolr_multisitesearch_search($op = 'search', $keys = NULL) {

  switch ($op) {
    case 'name':
      return t('Multi-site search');

    case 'reset':
      return;

    case 'status':
      return;

    case 'search':
      $filters = isset($_GET['filters']) ? $_GET['filters'] : '';
      $solrsort = isset($_GET['solrsort']) ? $_GET['solrsort'] : '';
      $page = isset($_GET['page']) ? $_GET['page'] : 0;
      try {
        $results = apachesolr_multisitesearch_execute($keys, $filters, $solrsort, 'search/' . arg(1), $page);
        return $results;
      }
      catch (Exception $e) {
        watchdog('Apache Solr Multisite', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
      }
      break;
  } // switch
}

/**
 * Execute a search results based on keyword, filter, and sort strings.
 *
 * @throws Exception
 */
function apachesolr_multisitesearch_execute($keys, $filters, $solrsort, $base_path = '', $page = 0, $caller = 'apachesolr_multisitesearch') {

  $params = array();
  // This is the object that knows about the query coming from the user.
  $query = apachesolr_drupal_query($keys, $filters, $solrsort, $base_path);
  if (empty($query)) {
    throw new Exception(t('Could not construct a Solr query in function apachesolr_search_search()'));
  }
  $query->multisite = TRUE;
  // This is the object that does the communication with the solr server.
  $solr = apachesolr_get_solr();
  $params += apachesolr_multisitesearch_basic_params($query);
  if ($keys) {
    $params += apachesolr_search_highlighting_params($query);
    $params += apachesolr_search_spellcheck_params($query);
  }
  else {
    // No highlighting, use the teaser as a snippet.
    $params['fl'] .= ',teaser';
  }
  
  apachesolr_search_add_boost_params($params, $query, $solr);

  // Allow modules to alter the query prior to statically caching it.
  // This can e.g. be used to add available sorts.
  foreach (module_implements('apachesolr_prepare_query') as $module) {
    $function_name = $module . '_apachesolr_prepare_query';
    $function_name($query, $params, $caller);
  }

  // Cache the built query. Since all the built queries go through
  // this process, all the hook_invocations will happen later
  apachesolr_current_query($query);

  // This hook allows modules to modify the query and params objects.
  apachesolr_modify_query($query, $params, $caller);
  $params['start'] = $page * $params['rows'];

  if (!$query) {
    return array();
  }

  if (('' == $keys) && isset($params['fq'])) {
    // Move the fq params to the q.alt for better performance.
    $params['q.alt'] = implode(' ', $params['fq']);
    unset($params['fq']);
  }

  // We must run htmlspecialchars() here since converted entities are in the index.
  // and thus bare entities &, > or < won't match.
  $response = $solr->search(htmlspecialchars($query->get_query_basic(), ENT_NOQUOTES, 'UTF-8'), $params['start'], $params['rows'], $params);
  // The response is cached so that it is accessible to the blocks and anything
  // else that needs it beyond the initial search.
  apachesolr_static_response_cache($response);
  //apachesolr_has_searched(TRUE);
  // Add search terms and filters onto the breadcrumb.
  drupal_set_breadcrumb(array_merge(menu_get_active_breadcrumb(), $query->get_breadcrumb()));
  return apachesolr_process_response($response, $query, $params);
}

/**
 * Implementation of hook_apachesolr_modify_query().
 */
function apachesolr_multisitesearch_apachesolr_modify_query(&$query, &$params, $caller) {
  if ($caller != 'apachesolr_multisitesearch') {
    // Limit single site searchs via the site hash.
    $query->add_filter('hash', apachesolr_site_hash());
  }
}

function apachesolr_multisitesearch_basic_params($query) {
  $params = array(
    'fl' => 'id,nid,title,comment_count,type,created,changed,score,path,url,uid,name,site,hash',
    'rows' => variable_get('apachesolr_rows', 10),
    'facet' => 'true',
    'facet.mincount' => 1,
    'facet.sort' => 'true'
  );
  return $params;
}

/**
 * Implementation of hook_theme().
 */
function apachesolr_multisitesearch_theme() {
  return array(
    'apachesolr_multisitesearch_username' => array(
      'arguments' => array('doc' => NULL),
    ),
  );
}

/**
 * Modified username theme function.
 *
 * @see theme_username()
 */
function theme_apachesolr_multisitesearch_username($doc) {

  if ($object->name) {
    // Shorten the name when it is too long or it will break many tables.
    if (drupal_strlen($object->name) > 20) {
      $name = drupal_substr($object->name, 0, 15) .'...';
    }
    else {
      $name = $object->name;
    }

    // Only make links for local users.
    if ($object->uid && apachesolr_site_hash() == $doc->hash && user_access('access user profiles')) {
      $output = l($name, 'user/'. $object->uid, array('attributes' => array('title' => t('View user profile.'))));
    }
    else {
      $output = check_plain($name);
    }
  }
  else {
    $output = check_plain(variable_get('anonymous', t('Anonymous')));
  }

  return $output;
}
