<?php
// $Id$

/**
 * @file
 *   Provides a multi-site search implementation for use with the Apache Solr module
 */


function apachesolr_multisitesearch_metadata() {
  $document = new Apache_Solr_Document();
  $document->id = apachesolr_document_id(0, 'multisite_metadata');
  $document->site = url(NULL, array('absolute' => TRUE));
  $document->hash = apachesolr_site_hash();
  $document->entity = 'multisite_meta';
  $document->ss_multisite_meta_sitename = variable_get('site_name', 'Drupal');
  module_load_include('inc', 'apachesolr', 'apachesolr.index');
  if (module_exists('taxonomy')) {
    $vocabs = taxonomy_get_vocabularies();
    foreach ($vocabs as $vid => $vocab) {
          // We index each name as a string for cross-site faceting
        // using the vocab name rather than vid in field construction .
        $document->setMultiValue('sm_multisite_meta_taxonomy', apachesolr_vocab_name($vid));
    }
  }
  drupal_alter('apachesolr_multisitesearch_metadata', $document);
  return $document;
}

/**
 * Implementation of hook_cron().
 */
function apachesolr_multisitesearch_cron() {
  // Update meta data 1x per day.
  $last = variable_get('apachesolr_multisitesearch_last_metadata', 0);
  $time = time();
  if ($time - $last > 60*60*24 || 1) {
    if (apachesolr_multisitesearch_update_metadata()) {
      variable_set('apachesolr_multisitesearch_last_metadata', $time);
    }
  }
  if (1) {
    apachesolr_multisitesearch_get_metadata();
  }
}

function apachesolr_multisitesearch_update_metadata() {
  try {
    // Get the $solr object
    $solr = apachesolr_get_solr();
    $metadata_doc = apachesolr_multisitesearch_metadata();
    $solr->addDocuments(array($metadata_doc));
    watchdog('Apache Solr Multisite', 'Updated site meta data');
  }
  catch (Exception $e) {
    watchdog('Apache Solr Multisite', 'Indexing failed for meta data <br /> !message',
             array('!message' => nl2br(strip_tags($e->getMessage()))), WATCHDOG_ERROR);
  }
}

function apachesolr_multisitesearch_get_metadata() {
  try {
    // Get the $solr object
    $solr = apachesolr_get_solr();
    $params['qt'] = 'standard';
    $params['fl'] = '*';
    $response = $solr->search('entity:multisite_meta', 0, 100, $params);
    foreach ($response->response->docs as $doc) {
      // Convert doc into a simple array.
      if (isset($doc->hash)) {
        foreach ($doc as $k => $v) {
          $data[$doc->hash][$k] = $v;
        }
      }
    }
    watchdog('Apache Solr Multisite', 'Fetched site meta data');
    variable_set('apachesolr_multisitesearch_metadata', $data);
  }
  catch (Exception $e) {
    watchdog('Apache Solr Multisite', 'Failed to fetch meta data <br /> !message',
             array('!message' => nl2br(strip_tags($e->getMessage()))), WATCHDOG_ERROR);
  }
}

/**
 * Implementation of hook_menu_alter().
 */
function apachesolr_multisitesearch_menu_alter(&$menu) {
  if (isset($menu['search/apachesolr_multisitesearch/%menu_tail'])) {
    $menu['search/apachesolr_multisitesearch/%menu_tail']['page callback'] = 'apachesolr_search_view';
  }
}

/**
 * Implementation of hook_search()
 */
function apachesolr_multisitesearch_search($op = 'search', $keys = NULL) {

  switch ($op) {
    case 'name':
      return t('Multi-site search');

    case 'reset':
      return;

    case 'status':
      return;

    case 'search':
      $filters = isset($_GET['filters']) ? $_GET['filters'] : '';
      $solrsort = isset($_GET['solrsort']) ? $_GET['solrsort'] : '';
      $page = isset($_GET['page']) ? $_GET['page'] : 0;
      try {
        $results = apachesolr_multisitesearch_execute($keys, $filters, $solrsort, 'search/' . arg(1), $page);
        return $results;
      }
      catch (Exception $e) {
        watchdog('Apache Solr Multisite', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
      }
      break;
  } // switch
}

/**
 * Execute a search results based on keyword, filter, and sort strings.
 *
 * @throws Exception
 */
function apachesolr_multisitesearch_execute($keys, $filters, $solrsort, $base_path = '', $page = 0, $caller = 'apachesolr_multisitesearch') {

  $params = array();
  // This is the object that knows about the query coming from the user.
  $query = apachesolr_drupal_query($keys, $filters, $solrsort, $base_path);
  if (empty($query)) {
    throw new Exception(t('Could not construct a Solr query in function apachesolr_search_search()'));
  }
  $query->multisite = TRUE;
  // This is the object that does the communication with the solr server.
  $solr = apachesolr_get_solr();
  $params += apachesolr_multisitesearch_basic_params($query);
  if ($keys) {
    $params += apachesolr_search_highlighting_params($query);
    $params += apachesolr_search_spellcheck_params($query);
  }
  else {
    // No highlighting, use the teaser as a snippet.
    $params['fl'] .= ',teaser';
  }
  apachesolr_multisitesearch_add_facet_params($params, $query);
  apachesolr_search_add_boost_params($params, $query, $solr);

  // Allow modules to alter the query prior to statically caching it.
  // This can e.g. be used to add available sorts.
  foreach (module_implements('apachesolr_prepare_query') as $module) {
    $function_name = $module . '_apachesolr_prepare_query';
    $function_name($query, $params, $caller);
  }

  // Cache the built query. Since all the built queries go through
  // this process, all the hook_invocations will happen later
  apachesolr_current_query($query);

  // This hook allows modules to modify the query and params objects.
  apachesolr_modify_query($query, $params, $caller);
  $params['start'] = $page * $params['rows'];

  if (!$query) {
    return array();
  }

  if (('' == $keys) && isset($params['fq'])) {
    // Move the fq params to the q.alt for better performance.
    $params['q.alt'] = implode(' ', $params['fq']);
    unset($params['fq']);
  }

  // We must run htmlspecialchars() here since converted entities are in the index.
  // and thus bare entities &, > or < won't match.
  $response = $solr->search(htmlspecialchars($query->get_query_basic(), ENT_NOQUOTES, 'UTF-8'), $params['start'], $params['rows'], $params);
  // The response is cached so that it is accessible to the blocks and anything
  // else that needs it beyond the initial search.
  apachesolr_static_response_cache($response);
  apachesolr_multisitesearch_has_searched(TRUE);
  // Add search terms and filters onto the breadcrumb.
  drupal_set_breadcrumb(array_merge(menu_get_active_breadcrumb(), $query->get_breadcrumb()));
  return apachesolr_process_response($response, $query, $params);
}

function apachesolr_multisitesearch_add_facet_params(&$params, $query) {
  $facet_query_limits = variable_get('apachesolr_facet_query_limits', array());
  $facet_missing = variable_get('apachesolr_facet_missing', array());

    foreach(apachesolr_multisitesearch_enabled_facets() as $delta => $facet_field) {
      // TODO: generalize handling of date and range facets.
      if (($facet_field == 'created' || $facet_field == 'changed')) {
        list($start, $end, $gap) = apachesolr_search_date_range($query, $facet_field);
        if ($gap) {
          $params['facet.date'][] = $facet_field;
          $params['f.'. $facet_field .'.facet.date.start'] = $start;
          $params['f.'. $facet_field .'.facet.date.end'] = $end;
          $params['f.'. $facet_field .'.facet.date.gap'] = $gap;
        }
      }
      else {
        $params['facet.field'][] = $facet_field;
        // Facet limits
        if (isset($facet_query_limits[$module][$delta])) {
          $params['f.' . $facet_field . '.facet.limit'] = $facet_query_limits[$module][$delta];
        }
        // Facet missing
        if (!empty($facet_missing[$module][$delta])) {
          $params['f.' . $facet_field . '.facet.missing'] = 'true';
        }
      }
    }


  if (!empty($params['facet.field'])) {
    // Add a default limit for fields where no limit was set.
    $params['facet.limit'] = variable_get('apachesolr_facet_query_limit_default', 20);
  }
}


function apachesolr_multisitesearch_has_searched($set = NULL) {
  static $searched = FALSE;
  if (isset($set)) {
    $searched = !empty($set);
  }
  return $searched;
}

/**
 * Implementation of hook_apachesolr_modify_query().
 */
function apachesolr_multisitesearch_apachesolr_modify_query(&$query, &$params, $caller) {
  if ($caller != 'apachesolr_multisitesearch') {
    // Limit single site searchs via the site hash.
    $query->add_filter('hash', apachesolr_site_hash());
  }
}

function apachesolr_multisitesearch_basic_params($query) {
  $params = array(
    'fl' => 'id,nid,title,comment_count,type_name,entity,created,changed,score,url,uid,name,site,hash',
    'rows' => variable_get('apachesolr_rows', 10),
    'facet' => 'true',
    'facet.mincount' => 1,
    'facet.sort' => 'true'
  );
  return $params;
}

function apachesolr_multisitesearch_process_response($response, $query, $params) {
  $results = array();
  // We default to getting snippets from the body.
  $hl_fl = is_null($params['hl.fl']) ? 'body' : $params['hl.fl'];
  $total = $response->response->numFound;
  apachesolr_pager_init($total, $params['rows']);
  if ($total > 0) {
    foreach ($response->response->docs as $doc) {
      $extra = array();

      // Find the nicest available snippet.
      if (isset($response->highlighting->{$doc->id}->$hl_fl)) {
        $snippet = theme('apachesolr_search_snippets', $doc, $response->highlighting->{$doc->id}->$hl_fl);
      }
      elseif (isset($doc->teaser)) {
        $snippet = theme('apachesolr_search_snippets', $doc, array(truncate_utf8($doc->teaser, 256, TRUE)));
      }
      else {
        $snippet = '';
      }

      if (!isset($doc->body)) {
        $doc->body = $snippet;
      }
      $doc->created = strtotime($doc->created);
      $doc->changed = strtotime($doc->changed);
      // Allow modules to alter each document.
      drupal_alter('apachesolr_search_result', $doc);
      // Copy code from comment_nodeapi().
      $extra[] = format_plural($doc->comment_count, '1 comment', '@count comments');
      $results[] = array(
        'link' => $doc->url,
        'type' => $doc->type_name,
        // template_preprocess_search_result() runs check_plain() on the title
        // again.  Decode to correct the display.
        'title' => htmlspecialchars_decode($doc->title, ENT_QUOTES),
        'user' => theme('apachesolr_multisitesearch_username', $doc),
        'date' => $doc->created,
        'node' => $doc,
        'extra' => $extra,
        'score' => $doc->score,
        'snippet' => $snippet,
      );
    }

    // Hook to allow modifications of the retrieved results
    foreach (module_implements('apachesolr_process_results') as $module) {
      $function = $module .'_apachesolr_process_results';
      $function($results);
    }
  }
  return $results;
}


/**
 * Implementation of hook_block().
 */
function apachesolr_multisitesearch_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $enabled_facets = apachesolr_multisitesearch_enabled_facets();
      $facets = apachesolr_multisitesearch_facets();
      // Add the blocks
      $blocks = array();
      foreach ($enabled_facets as $delta => $facet_field) {
        if (isset($facets[$delta])) {
          $blocks[$delta] = $facets[$delta] + array('cache' => BLOCK_CACHE_PER_PAGE,);
        }
      }
      $blocks['currentsearch'] = array(
        'info' => t('Apache Solr Multisite Search: Current search'),
        'cache' => BLOCK_CACHE_PER_PAGE,
      );
      return $blocks;

    case 'view':
      if (apachesolr_multisitesearch_has_searched()) {
        // Get the query and response. Without these no blocks make sense.
        $response = apachesolr_static_response_cache();
        if (empty($response)) {
          return;
        }
        $query = apachesolr_current_query();
        switch ($delta) {
          case 'currentsearch':
            return apachesolr_multisitesearch_currentsearch($query);
           case 'name':
            return apachesolr_facet_block($response, $query, 'apachesolr_multisitesearch', $delta, $delta, t('Filter by author'));
          case 'type_name':
            return apachesolr_facet_block($response, $query, 'apachesolr_multisitesearch', $delta, $delta, t('Filter by type'));
          case 'changed':
            return apachesolr_date_facet_block($response, $query, 'apachesolr_multisitesearch', $delta, $delta, t('Filter by modification date'));
          case 'created':
            return apachesolr_date_facet_block($response, $query, 'apachesolr_multisitesearch', $delta, $delta, t('Filter by post date'));
          case 'hash':
            return apachesolr_facet_block($response, $query, 'apachesolr_multisitesearch', $delta, $delta, t('Filter by site'), 'theme_apachesolr_breadcrumb_hash');
        }
      }
      break;

    case 'configure':
      if ($delta != 'currentsearch') {
        return apachesolr_facetcount_form('apachesolr_multisitesearch', $delta);
      }
      break;

    case 'save':
      if ($delta != 'currentsearch') {
        apachesolr_facetcount_save($edit);
      }
      break;
  }
}

function apachesolr_multisitesearch_currentsearch($query) {
    $fields = $query->get_filters();
    $path = $query->get_path();
    $options = array();
    if (!$fields) {
      $options['attributes']['class'] = 'active';
    }
    $links[] = apachesolr_l($query->get_query_basic(), $path, $options);
    foreach($fields as $field) {
      if ($field['#name']) {
        $new_query = clone $query;
        $new_query->remove_filter($field['#name'], $field['#value']);
        $options['query'] = $new_query->get_url_queryvalues();
        $fielddisplay = theme("apachesolr_breadcrumb_". $field['#name'], $field['#value']);
        if (!$fielddisplay) {
          $fielddisplay = $field['#value'];
        }
        $links[] = theme('apachesolr_unclick_link', $fielddisplay, $new_query->get_path(), $options);
      }
    }
    $content = theme('apachesolr_currentsearch', $response->response->numFound, $links);
    return array('subject' => t('Current search'), 'content' => $content);
}

function apachesolr_multisitesearch_enabled_facets() {
  return array(
    'type_name' => 'type_name',
    'name' => 'name',
    'created' => 'created',
  );
}

/**
 * Implementation of hook_apachesolr_facets().
 *
 * Returns an array keyed by block delta.
 */
function apachesolr_multisitesearch_facets() {
  $facets = array();

  $facets['type_name'] = array(
    'info' => t('Apache Solr Multisite Search: Filter by content type'),
    'facet_field' => 'type_name',
  );

  $facets['name'] = array(
    'info' => t('Apache Solr Multisite Search: Filter by author'),
    'facet_field' => 'name',
  );

  $facets['changed'] = array(
    'info' => t('Apache Solr Multisite Search: Filter by updated date'),
    'facet_field' => 'changed',
  );
  $facets['created'] = array(
    'info' => t('Apache Solr Multisite Search: Filter by post date'),
    'facet_field' => 'created',
  );
  $facets['hash'] = array(
    'info' => t('Apache Solr Multisite Search: Filter by site'),
    'facet_field' => 'hash',
  );
  // Get taxonomy vocabulary facets.
  // @todo - use meta data also/instead.
  if (module_exists('taxonomy')) {
    module_load_include('inc', 'apachesolr', 'apachesolr.index');
    $vocabs = taxonomy_get_vocabularies();
    foreach ($vocabs as $vid => $vocab) {
      // In this case the delta and facet field are the same.
      $delta = 'sm_vid_'. apachesolr_vocab_name($vid);
      $facets[$delta] = array(
        'info' => t('Apache Solr Multisite Search: Filter by taxonomy @name', array('@name' => $vocab->name)),
        'facet_field' => $delta,
      );
    }
  }

  return $facets;
}


/**
 * Implementation of hook_theme().
 */
function apachesolr_multisitesearch_theme() {
  return array(
    'apachesolr_multisitesearch_username' => array(
      'arguments' => array('doc' => NULL),
    ),
    'apachesolr_breadcrumb_hash' => array(
      'arguments' => array('hash' => NULL, 'exclude' => FALSE),
    ),
  );
}

function theme_apachesolr_breadcrumb_hash($hash, $exclude = FALSE) {
  static $meta;
  if (!isset($meta)) {
    $meta = variable_get('apachesolr_multisitesearch_metadata', array());
  }
  if ($hash == apachesolr_site_hash()) {
    return t('This site (!site)', array('!site' => variable_get('site_name', 'Drupal')));
  }
  elseif (isset($meta[$hash]['ss_multisite_meta_sitename'])) {
    return $meta[$hash]['ss_multisite_meta_sitename'];
  }
  return $hash;
}

/**
 * Modified username theme function.
 *
 * @see theme_username()
 */
function theme_apachesolr_multisitesearch_username($doc) {

  if ($object->name) {
    // Shorten the name when it is too long or it will break many tables.
    if (drupal_strlen($object->name) > 20) {
      $name = drupal_substr($object->name, 0, 15) .'...';
    }
    else {
      $name = $object->name;
    }

    // Only make links for local users.
    if ($object->uid && apachesolr_site_hash() == $doc->hash && user_access('access user profiles')) {
      $output = l($name, 'user/'. $object->uid, array('attributes' => array('title' => t('View user profile.'))));
    }
    else {
      $output = check_plain($name);
    }
  }
  else {
    $output = check_plain(variable_get('anonymous', t('Anonymous')));
  }

  return $output;
}
